// Copyright 2025 Francisco F. Pinochet
// Copyright 2026 Fastcomcorp
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

//! Stream Recording Service
//!
//! Records live stream HLS segments and triggers VOD conversion after stream ends

use crate::error::{LiveIngestError, Result};
use armoricore_types::events::{Event, EventType};
use message_bus_client::traits::MessageBusClient;
use std::collections::HashMap;
use std::path::PathBuf;
use std::sync::Arc;
use tokio::fs;
use tokio::sync::RwLock;
use tracing::info;

/// Stream recorder that records HLS segments during live streaming
pub struct StreamRecorder {
    stream_id: String,
    recording_id: String,
    segments_dir: PathBuf,
    storage_path: String,
    recorded_segments: Arc<RwLock<Vec<RecordedSegment>>>,
    message_bus: Arc<dyn MessageBusClient>,
}

/// Recorded segment metadata
#[derive(Debug, Clone)]
struct RecordedSegment {
    segment_path: PathBuf,
    segment_number: u64,
    quality: String,
    size_bytes: u64,
    timestamp: chrono::DateTime<chrono::Utc>,
}

impl StreamRecorder {
    /// Create a new stream recorder
    pub fn new(
        stream_id: String,
        recording_id: String,
        segments_dir: PathBuf,
        storage_path: String,
        message_bus: Arc<dyn MessageBusClient>,
    ) -> Self {
        Self {
            stream_id,
            recording_id,
            segments_dir,
            storage_path,
            recorded_segments: Arc::new(RwLock::new(Vec::new())),
            message_bus,
        }
    }

    /// Start recording a stream
    /// 
    /// This monitors the segments directory and records all HLS segments
    /// as they are generated by the live transcoder.
    pub async fn start_recording(&self) -> Result<()> {
        info!(
            stream_id = self.stream_id,
            recording_id = self.recording_id,
            segments_dir = ?self.segments_dir,
            "Starting stream recording"
        );

        // Ensure segments directory exists
        if !self.segments_dir.exists() {
            fs::create_dir_all(&self.segments_dir)
                .await
                .map_err(|e| LiveIngestError::Io(e))?;
        }

        info!(
            stream_id = self.stream_id,
            "Stream recording started"
        );

        Ok(())
    }

    /// Record a segment (called when a new segment is generated)
    pub async fn record_segment(
        &self,
        segment_path: &PathBuf,
        quality: &str,
        segment_number: u64,
    ) -> Result<()> {
        // Get segment metadata
        let metadata = fs::metadata(segment_path)
            .await
            .map_err(|e| LiveIngestError::Io(e))?;
        let size_bytes = metadata.len();

        let recorded_segment = RecordedSegment {
            segment_path: segment_path.to_path_buf(),
            segment_number,
            quality: quality.to_string(),
            size_bytes,
            timestamp: chrono::Utc::now(),
        };

        // Store segment metadata
        {
            let mut segments = self.recorded_segments.write().await;
            segments.push(recorded_segment.clone());
        }

        info!(
            stream_id = self.stream_id,
            quality = quality,
            segment_number = segment_number,
            size_bytes = size_bytes,
            "Segment recorded"
        );

        Ok(())
    }

    /// Stop recording and prepare for VOD conversion
    pub async fn stop_recording(&self) -> Result<RecordingResult> {
        info!(
            stream_id = self.stream_id,
            recording_id = self.recording_id,
            "Stopping stream recording"
        );

        let segments = {
            let segments = self.recorded_segments.read().await;
            segments.clone()
        };

        let total_segments = segments.len();
        let total_size_bytes: u64 = segments.iter().map(|s| s.size_bytes).sum();

        info!(
            stream_id = self.stream_id,
            total_segments = total_segments,
            total_size_bytes = total_size_bytes,
            "Recording stopped"
        );

        // Trigger VOD conversion
        self.trigger_vod_conversion(&segments).await?;

        Ok(RecordingResult {
            recording_id: self.recording_id.clone(),
            stream_id: self.stream_id.clone(),
            total_segments,
            total_size_bytes,
            storage_path: self.storage_path.clone(),
        })
    }

    /// Trigger VOD conversion by publishing an event
    async fn trigger_vod_conversion(&self, segments: &[RecordedSegment]) -> Result<()> {
        info!(
            stream_id = self.stream_id,
            recording_id = self.recording_id,
            segments_count = segments.len(),
            "Triggering VOD conversion"
        );

        // Group segments by quality
        let mut segments_by_quality: HashMap<String, Vec<&RecordedSegment>> = HashMap::new();
        for segment in segments {
            segments_by_quality
                .entry(segment.quality.clone())
                .or_insert_with(Vec::new)
                .push(segment);
        }

        // Create VOD conversion event
        // Note: This would typically trigger the media processor to:
        // 1. Download all recorded segments
        // 2. Concatenate them into a single video file
        // 3. Transcode to VOD format
        // 4. Upload to object storage
        // 5. Publish media.ready event

        // For now, we'll publish a recording.complete event
        // The media processor can subscribe to this and handle VOD conversion
        let event = Event::new(
            EventType::StreamEnded, // Using StreamEnded for now, could add RecordingComplete event type
            "live-ingest",
            serde_json::json!({
                "stream_id": self.stream_id,
                "recording_id": self.recording_id,
                "storage_path": self.storage_path,
                "total_segments": segments.len(),
                "total_size_bytes": segments.iter().map(|s| s.size_bytes).sum::<u64>(),
                "segments_by_quality": segments_by_quality.iter().map(|(quality, segs)| {
                    (quality.clone(), segs.len())
                }).collect::<HashMap<String, usize>>(),
            }),
        )
        .map_err(|e| LiveIngestError::StreamManager(format!("Failed to create event: {}", e)))?;

        self.message_bus
            .publish(&event)
            .await
            .map_err(|e| LiveIngestError::StreamManager(format!("Failed to publish event: {}", e)))?;

        info!(
            stream_id = self.stream_id,
            recording_id = self.recording_id,
            "VOD conversion triggered"
        );

        Ok(())
    }

    /// Get recording statistics
    pub async fn get_stats(&self) -> RecordingStats {
        let segments = self.recorded_segments.read().await;
        let total_segments = segments.len();
        let total_size_bytes: u64 = segments.iter().map(|s| s.size_bytes).sum();
        let segments_by_quality: HashMap<String, usize> = segments
            .iter()
            .fold(HashMap::new(), |mut acc, s| {
                *acc.entry(s.quality.clone()).or_insert(0) += 1;
                acc
            });

        RecordingStats {
            stream_id: self.stream_id.clone(),
            recording_id: self.recording_id.clone(),
            total_segments,
            total_size_bytes,
            segments_by_quality,
        }
    }
}

/// Recording result
#[derive(Debug, Clone)]
pub struct RecordingResult {
    pub recording_id: String,
    pub stream_id: String,
    pub total_segments: usize,
    pub total_size_bytes: u64,
    pub storage_path: String,
}

/// Recording statistics
#[derive(Debug, Clone)]
pub struct RecordingStats {
    pub stream_id: String,
    pub recording_id: String,
    pub total_segments: usize,
    pub total_size_bytes: u64,
    pub segments_by_quality: HashMap<String, usize>,
}

